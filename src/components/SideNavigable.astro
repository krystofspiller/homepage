---
import { parseHTML } from "linkedom"
import Link from "./Link.astro"

const html = await Astro.slots.render("default")
const { document } = parseHTML(html)

type Toc = Array<{ level: number; name: string; id: string | null }>

const toc: Toc = []
let minLevel = Number.MAX_SAFE_INTEGER
function getHeadings(content: Document | HTMLElement | null, toc: Toc) {
  const children = content?.children ?? []
  for (const c of children) {
    const child = c as HTMLElement
    if (["H1", "H2", "H3"].includes(child.tagName)) {
      const level = parseInt(child.tagName.split("H")[1])
      minLevel = Math.min(minLevel, level)
      toc.push({
        level,
        name: child.getAttribute("data-toc") ?? child.innerText?.trim(),
        id: child.getAttribute("id"),
      })
    }
    getHeadings(child, toc)
  }
}
getHeadings(document, toc)
---

<div>
  <div
    class="sticky top-16 ml-[576px] hidden h-0 min-w-56 text-xs leading-6 text-zinc-400 lg:block"
  >
    <ul class="h-[calc(100vh-4rem)] overflow-scroll p-4 pt-0">
      {
        toc.map((val) => (
          <li
            data-id={val.id}
            style={`margin-left: ${val.level - minLevel}rem`}
          >
            <Link className="!no-underline" href={`#${val.id}`}>
              {val.name}
            </Link>
          </li>
        ))
      }
    </ul>
  </div>
  <div
    class="fixed bottom-0 left-0 z-100 flex h-14 w-full items-center justify-center bg-neutral-950 p-2 text-zinc-400 lg:hidden"
  >
    <select
      class="rounded-lg border border-neutral-800 p-2.5 pr-10 text-zinc-400 outline-none focus:border-blue-500 focus:ring-blue-500"
      id="mobile-toc-select"
    >
      {
        toc.map((val) => (
          <option value={val.id}>
            {"\u00A0\u00A0".repeat(val.level - minLevel)}
            {val.name}
          </option>
        ))
      }
    </select>
  </div>
  <slot />
</div>

<script>
  import { usesSideNavigable } from "@utils/store"
  usesSideNavigable.set(true)
</script>

<script is:inline data-astro-rerun define:vars={{ toc }}>
  const mobileSelect = document.getElementById("mobile-toc-select")
  mobileSelect?.addEventListener("change", (e) => {
    const selectedId = e.target.value
    if (!selectedId) {
      return
    }

    const element = document.getElementById(selectedId)
    element?.scrollIntoView({ behavior: "smooth" })
  })

  const intersecting = new Map()
  let closestTarget = null
  function handleIntersect(entries) {
    closestTarget?.classList.remove("text-white")
    entries.forEach((entry) => {
      const targetId = entry.target.getAttribute("id")
      if (entry.isIntersecting) {
        intersecting.set(targetId, entry.target)
      } else {
        intersecting.delete(targetId)
        document
          .querySelector(`li[data-id=${targetId}]`)
          ?.classList.remove("text-white")
      }
    })

    if (intersecting.size === 0) {
      let largestNegativeDiff = Number.MIN_SAFE_INTEGER
      let closestId = null
      for (const row of toc) {
        const top = document.getElementById(row.id)?.getBoundingClientRect().top
        if (top > 0) continue

        if (top > largestNegativeDiff) {
          largestNegativeDiff = top
          closestId = row.id
        }
      }

      closestTarget = document.querySelector(`li[data-id=${closestId}]`)
      closestTarget?.classList.add("text-white")
      if (mobileSelect) {
        mobileSelect.value = closestId
      }
    }

    let top = [Number.MAX_SAFE_INTEGER, null, null]
    intersecting.forEach((target, targetId) => {
      const li = document.querySelector(`li[data-id=${targetId}]`)
      const positionFromTop = target.getBoundingClientRect().top
      if (positionFromTop < top[0]) {
        top = [positionFromTop, li, targetId]
      }
      li?.classList.remove("text-white")
    })

    top[1]?.classList.add("text-white")
    if (top[2] && mobileSelect) {
      mobileSelect.value = top[2]
    }
  }
  const observer = new IntersectionObserver(handleIntersect, { threshold: 1 })
  for (const row of toc) {
    observer.observe(document.getElementById(row.id))
  }
</script>
